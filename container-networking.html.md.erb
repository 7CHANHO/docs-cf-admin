---
title: Container Networking
owner: Diego Networking
---

This topic provides an overview of container networking in Cloud Foundry (CF) and describes how to enable and use the feature. 

##<a id="about"></a>About Container Networking

See the following sections to understand how container networking works in CF. 
The Diego cells that host apps in CF run each app instance in a container. 
Without container networking, all app to app traffic must go through the Gorouter. 
With container networking, apps can communicate directly. 

###<a id="overview"></a> Overview

You can enable container networking in CF by adding the container-networking BOSH release to your deployment. 

Enabling container networking for your deployment allows you to create policies for communication between containers. 
The container-networking feature also provides a unique IP address to each container that is accessible outside of the 
Diego cell on which the container runs, allowing you to know which container traffic comes from. 

The policies you create specify a source app, destination app, protocol, and port so that apps can communicate directly 
without going through the Gorouter, a load balancer, or a firewall. 
Container networking in CF supports UDP and TCP, and you can configure policies for multiple ports. 
These policies are applied immediately without having to restart the app. 

The container-networking BOSH release is composed of a pluggable network stack, which means you can swap several components. 
For more information, see [Architecture](#architecture) below. 


#### Without Container Networking

The diagram below illustrates how two apps communicate in a deployment without container networking enabled. 
Traffic from **App A** must route out and back in through the Gorouter, which restricts performance and the protocol used to send the traffic. 
In this scenario, **App B** does not know the real source of the traffic it receives and must trust all inbound traffic. 

![Pre Container Networking](./images/pre-c2c.png)

#### With Container Networking

The diagram below illustrates how apps communicate in a deployment with container networking enabled. 
In this example, the operator creates two policies to regulate the flow of traffic between **App A**, **App B**, and **App C**. 

* Allow traffic from **App A** to **App B**
* Allow traffic from **App A** to **App C**

If traffic and its direction is not explicitly allowed, it is denied. In this case, **App B** cannot send traffic to **App C**.

![Post Container Networking](./images/post-c2c.png)

###<a id="architecture"></a> Architecture

Container networking in CF integrates with Garden-runC in a Diego deployment. 
The BOSH release for container networking includes several core components, as well as swappable components. 

To understand the components and how they work, refer to the diagram and tables below. 

![c2c architecture diagram](./images/c2c-arch.png)

#### Core Components

The core components included in the container-networking BOSH release are as follows:

<table>
  <tr>
    <th>Part</th>
    <th>Function</th>
  </tr>
  <tr>
    <td>cf CLI plugin</td>
    <td>A plugin that you download to control network access policies between apps. 
        See <a href="create-policies">Create Policies for Container Networking.</a></td>
  </tr>
  <tr>
    <td>Policy Server</td>
    <td>A central management node that does the following:
      <ul>
        <li>Exposes a JSON REST API used by the cf CLI plugin</li>
        <li>Maintains a policy database</li>
      </ul></td>
  </tr>
  <tr>
    <td>Garden External Networker</td>
    <td> 
      A Garden-runC add-on deployed to every Diego cell that does the following:
      <ul>
        <li>Invokes the CNI Plugin component to set up the network for each app</li>
        <li>Forwards ports to support incoming connections from the CF HTTP Router, TCP Router, and Diego SSH Proxy. 
            This keeps apps externally reachable.</li>
        <li>Installs outbound whitelist rules to support CF Application Security Groups (ASGs). See the <a href="app-sec-groups.html">ASG documentation</a>.</li>
      </ul>
    </td>
  </tr>
</table>

#### Swappable Components

The swappable components included in the container-networking BOSH release are as follows:

<table>
  <tr>
    <th>Part</th>
    <th>Function</th>
  </tr>
  <tr>
  <td>Flannel CNI plugin</td>
  <td>A plugin that provides IP address management and network connectivity to apps.
  <ul>
  <li>Acquires IP address of container and relays to Garden</li>
  <li>Installs network interface in container using the the flannel VXLAN backend. This is a shared, flat L3 network.</li>
  </td>
  </ul>
  </tr>
  <tr>
  <td>VXLAN Policy Agent</td>
  <td>Enforces network policy for network traffic between apps
  <ul>
  <li>Discovers desired network policies from the Policy Server Internal API</li>
  <li>Updates IPTables rules on Diego cell to allow whitelisted inbound traffic </li>
  <li>Tags outbound traffic with the unique identifier of the source app using the VXLAN Group-Based Policy (GBP) header</li>
  </ul>
  </td>
  </tr>
</table> 

##<a id="enable"></a>Enable Container Networking

###<a id="iaas"></a>Enable on IaaS

#### Prerequisites

To complete this procedures, you need a MySQL or PostgreSQL database. 
You could use an instance within the Cloud Controller database or spin up another instance, such as Amazon RDS.

<ol>
    <li>Target your bosh director using the BOSH CLI:<br>
    <code>
    $ bosh target BOSH-DIRECTOR-IP
    </code>
    </li>

    <li>If you have not already, upload a stemcell that uses Linux kernel 4.4, such as stemcell 3263.2 or later:<br>
<code>
    $ bosh upload stemcell URL-OF-STEMCELL
    </code>
    </li>

    <li>Open the CF properties stub that you created when <a href="http://docs.cloudfoundry.org/deploying/index.html">deploying Cloud Foundry</a>
        and do the following:
    <ol type="a">
        <li>Under <code>properties</code> > <code>uaa</code> > <code>scim</code> > <code>users</code> > <code>name: admin</code> > <code>groups</code>, add a new group called <code>network.admin</code>.</li>
        <li>Under <code>properties</code> > <code>uaa</code> > <code>clients</code> > <code>cf</code>, to the line beginning <code>scope: </code>
        add <code>network.admin</code>.</li>
        <pre>
clients:
  cf:
    scope: cloud_controller.read,&nbsp;[...]&nbsp;routing.router_groups.read,<strong>network.admin</strong></pre>
        <li><a name="uaa-secret"></a>Under the <code>cf</code> client, add a <code>network-policy</code> client, as follows:
        <pre>
clients:
  cf:
    scope:&nbsp;cloud_controller.read,&nbsp;[...]&nbsp;routing.router_groups.read,network.admin
  <strong>network-policy:
    authorities: uaa.resource,cloud_controller.admin_read_only
    authorized-grant-types: client_credentials,refresh_token
    secret: REPLACE_WITH_UAA_CLIENT_SECRET</strong></pre>
        Replace <code>REPLACE_WITH_UAA_CLIENT_SECRET</code> with a secure password of your choosing.  
        </li>
    </ol>
    </li>
    <li>Create a Container Networking stub by copying [LINK? SNIPPET BELOW?]. 
        For specific information about replacing the indicated values, see the following table.

<table border="1" class="nice">
  <tr>
    <th style="width:35%">Container Networking Stub Contents</th>
    <th>Editing Instructions</th>
  </tr>
  <tr>
    <td><pre><code>
properties:
  vxlan-policy-agent:
    policy_server_url: [...]
    ca_cert: |
      -----BEGIN CERTIFICATE-----
      REPLACE_WITH_CA_CERT
      -----END CERTIFICATE-----
    client_cert: |
      -----BEGIN CERTIFICATE-----
      REPLACE_WITH_CLIENT_CERT
      -----END CERTIFICATE-----
    client_key: |
      -----BEGIN RSA PRIVATE KEY-----
      REPLACE_WITH_CLIENT_KEY
      -----END RSA PRIVATE KEY-----</code></pre></td>
    <td>Paste in the certificates and keys for the policy agent. The policy agent communicates with the policy server through TLS.
    </td>
  </tr>
  <tr>
    <td><pre><code>
policy-server:
  uaa_client_secret: REPLACE_WITH_UAA_CLIENT_SECRET
    </code></pre></td>
    <td>Paste in the same value you used in the step <a href="#uaa-secret">above</a>.
    </td>
  </tr>
  <tr>
    <td><pre><code>
database:
  type: REPLACE_WITH_DB_TYPE 
  username: REPLACE_WITH_USERNAME
  password: REPLACE_WITH_PASSWORD
  host: REPLACE_WITH_DB_HOSTNAME
  port: REPLACE_WITH_DB_PORT 
  name: REPLACE_WITH_DB_NAME 
   </code></pre></td>
    <td>
    The database type must be <code>postgres</code> or <code>mysql</code>.<br>
    Supply the admin username and password for the database [MORE INFO ABOUT THIS DB].<br>
    Supply the IP address for the database.<br>
    For MySQL, the port number is <code>3306</code>, and for PostgreSQL, <code>????</code>.<br>
    Supply the name of the database.
    </td>
  </tr>
<tr>
    <td><pre><code>
ca_cert: |
        -----BEGIN CERTIFICATE-----
        REPLACE_WITH_CA_CERT
        -----END CERTIFICATE-----
      server_cert: |
        -----BEGIN CERTIFICATE-----
        REPLACE_WITH_SERVER_CERT
        -----END CERTIFICATE-----
      server_key: |
        -----BEGIN RSA PRIVATE KEY-----
        REPLACE_WITH_SERVER_KEY
        -----END RSA PRIVATE KEY-----
    garden-cni:
      cni_plugin_dir: /var/vcap/packages/flannel/bin
      cni_config_dir: /var/vcap/jobs/cni-flannel/config/cni
    </code></pre></td>
    <td>
    Paste in the certificates and keys for the policy server. The policy server communicates with the policy agent through TLS.
    </td>
  </tr>
</table>
<li>
Create a file that contains the following bash script. Name the file <code>generate_diego.sh</code>.
<pre>
set -e -x -u

environment_path=STUBS-DIRECTORY
output_path=MANIFEST-DIRECTORY
diego_release_path=LOCAL-DIEGO-REPO

pushd cf-release
  ./scripts/generate_deployment_manifest aws \
    ${environment_path}/stubs/director-uuid.yml \
    ${diego_release_path}/examples/aws/stubs/cf/diego.yml \
    ${environment_path}/stubs/cf/properties.yml \
    ${environment_path}/stubs/cf/instance-count-overrides.yml \
    ${environment_path}/stubs/cf/stub.yml \
    > ${output_path}/cf.yml
popd

pushd diego-release
  ./scripts/generate-deployment-manifest \
    -g \
    -c ${output_path}/cf.yml \
    -i ${environment_path}/stubs/diego/iaas-settings.yml \
    -p ${environment_path}/stubs/diego/property-overrides.yml \
    -n ${environment_path}/stubs/diego/instance-count-overrides.yml \
    -N ${environment_path}/stubs/netman/stub.yml \
    -v ${environment_path}/stubs/diego/release-versions.yml \
    > ${output_path}/diego.yml
popd
</pre>
Replace the variables as follows:<br>
<ul>
<li><code>STUBS-DIRECTORY</code>:  The directory containing your stubs for CF, Diego, and container networking.</li>
<li><code>MANIFEST-DIRECTORY</code>: The directory where you want the manifest created.</li>
<li><code>LOCAL-DIEGO-REPO</code>: The directory of the local copy of the <code>diego-release</code> repository.</li>
</ul>
</li>
<li>
Enter the following commands to make the script executable and run the script.
<pre>
$ chmod u+x generate_diego.sh
$ ./generate_diego.sh
</pre>
</li>
<li>
Enter the following command to target your BOSH director:
<pre>
$ bosh target BOSH-DIRECTOR-IP
</pre>
For example,
<pre class="terminal">$ bosh target 192.0.2.1</pre>
</li>
<li>
Enter the following command to set the deployment to the manifest you generated.
<pre>
$ bosh deployment ${output_path}/diego.yml
</pre>
</li>
<li>
Enter the following command to deploy.
<pre>$ bosh deploy</pre>
</li>
<li>(Optional) Try out the <a href="https://github.com/cloudfoundry-incubator/netman-release/tree/develop/src/example-apps/cats-and-dogs">Cats and Dogs</a> 
     example in the Container Networking Release repository. 
     In this tutorial, you deploy two apps and create a container-networking policy that 
     allows them to communicate directly with each other. 
 </li>
</ol>

###<a id="lite"></a>Enable on BOSH-Lite

If your Cloud Foundry deployment runs on BOSH-Lite, follow these steps to enable container networking. 
<ol>
  <li> Navigate to your `bosh-lite` directory, for example,
    <pre class="terminal">$ cd ~/workspace/bosh-lite </pre>
  </li>
  <li> Ensure that `br_netfilter` is enabled on the VM running BOSH-Lite:
    ```
    $ vagrant ssh -c 'sudo modprobe br_netfilter'
    WHAT SHOULD THE OUTPUT BE?
    ```
  </li>
     <li> If `br_netfilter` is not enabled on the VM:
     <ol type="a">
       <li> Open the `Vagrantfile` in the root of your `bosh-lite` directory.</li>
       <li> Add the following line to the file:</li>
        ```
         config.vm.provision "shell", inline: "sudo modprobe br_netfilter"
        ```
     </ol>
</li>

<li> Upload the latest BOSH-Lite stemcell:
  ```
  $ bosh upload stemcell https://bosh.io/d/stemcells/bosh-warden-boshlite-ubuntu-trusty-go_agent
  ```
  </li>
  <li>To clone the required Cloud Foundry release repos to your workspace, enter the following commands:<br>
  <code>
  $ git clone https<span>:</span>//github.com/cloudfoundry/diego-release<br>
  $ git clone https<span>:</span>//github.com/cloudfoundry/cf-release<br>
  $ git clone https<span>:</span>//github.com/cloudfoundry-incubator/netman-release
  </code>
  </li>
  <li>To enable container networking on BOSH-Lite, change directories into `netman-release` and run the deploy script:<br>
  <code>
  $ cd ~/workspace/netman-release
  $ ./scripts/deploy-to-bosh-lite
  </code>
  </li>
 <li>(Optional) Try out the <a href="https://github.com/cloudfoundry-incubator/netman-release/tree/develop/src/example-apps/cats-and-dogs">Cats and Dogs</a> 
     example in the Container Networking Release repository. 
     In this tutorial, you deploy two apps and create a container-networking policy that 
     allows them to communicate directly with each other. 
 </li>
</ol>
 




##<a id="create-policies"></a>Create Policies for Container Networking

This section describes how to create and modify container-networking policies using a plugin for the cf CLI.

To use the plugin, you must have the `network.admin` UAA scope.  

### Install the Plugin

Follow these steps to download and install the "netman" plugin for the cf CLI:

1. Download the `network-policy-plugin` for your operating system from the 
   [Container Networking Release repository](https://github.com/cloudfoundry-incubator/netman-release/releases).

1. To change the permissions of the plugin file and complete the installation, enter the following commands:

    ```
    $ chmod +x ~/Downloads/network-policy-plugin
    $ cf install-plugin ~/Downloads/network-policy-plugin
    ```

### Create a Policy

To create a policy that allows direct network traffic from one app to another, enter the following command:

```
$ cf allow-access SOURCE-APP DESTINATION-APP --protocol PROTOCOL --port PORT
 ```
Where:<br>
`SOURCE-APP` is the name of the app that will be sending traffic.<br>
`DESTINATION-APP` is the name of the app that will be receiving traffic.<br>
`PROTOCOL` is one of the following: `tcp` or `udp`.<br>
`PORT` is the port at which to connect to the destination app. The allowed range is 1 to 65535.<br>


For example, 

<pre class="terminal">
$ cf allow-access frontend backend --protocol tcp --port 8080
Allowing traffic from frontend to backend as admin...
OK 
</pre>

### List Policies

You can list all the policies in your deployment or just the policies for which a single app is 
either the source or the destination:

+ To list the all the policies in your deployment, enter the following command:

    ```
    $ cf list-access
    ```
+ To list the policies for an app, enter the following command:

    ```
    $ cf list-access --app MY-APP
    ```

    For example,
    
    <pre class="terminal">
    $ cf list-access --app frontend
    Listing policies as admin...
    OK
    
    Source    Destination    Protocol    Port
    frontend  backend        tcp         8080
    </pre>

### Delete a Policy

To delete a policy that allows direct network traffic from one app to another, enter the following command:

```
$ cf remove-access SOURCE-APP DESTINATION-APP --protocol PROTOCOL --port PORT
```

For example,
<pre class="terminal">
$ cf remove-access frontend backend --protocol tcp --port 8080
Denying traffic from frontend to backend as admin...
OK 
</pre>


